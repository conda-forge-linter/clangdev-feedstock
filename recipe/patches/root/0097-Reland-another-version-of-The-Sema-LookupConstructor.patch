From 009cc49c665c9c3d33e8d092fa7226f2250ff44a Mon Sep 17 00:00:00 2001
From: Vassil Vassilev <v.g.vassilev@gmail.com>
Date: Wed, 3 Mar 2021 21:39:04 +0000
Subject: [PATCH 097/107] Reland another version of "The
 Sema::LookupConstructor is not iteration safe."

When looking up a ctor the modules infrasturcture deserializes more ctor
candidates in the body of the function causing the internal vector implementation
to rellocate and invalidate the pointers.

This patch makes Sema::LookupConstructor void and stabilizes the iteration.

This patch is a previous version of the patch in https://reviews.llvm.org/D91524
and we, after being merged, we should be able to backport it.
---
 include/clang/Sema/Sema.h     |  3 ++-
 lib/Sema/SemaCodeComplete.cpp |  4 +++-
 lib/Sema/SemaDeclCXX.cpp      |  4 +++-
 lib/Sema/SemaExprCXX.cpp      |  8 ++++++--
 lib/Sema/SemaInit.cpp         | 20 +++++++++++++-------
 lib/Sema/SemaLookup.cpp       | 13 ++++++++++---
 lib/Sema/SemaOverload.cpp     |  8 ++++++--
 lib/Sema/SemaTemplate.cpp     |  4 +++-
 8 files changed, 46 insertions(+), 18 deletions(-)

diff --git a/include/clang/Sema/Sema.h b/include/clang/Sema/Sema.h
index 452deb4dfd..26f3d66995 100644
--- a/include/clang/Sema/Sema.h
+++ b/include/clang/Sema/Sema.h
@@ -3463,7 +3463,8 @@ public:
   LabelDecl *LookupOrCreateLabel(IdentifierInfo *II, SourceLocation IdentLoc,
                                  SourceLocation GnuLabelLoc = SourceLocation());
 
-  DeclContextLookupResult LookupConstructors(CXXRecordDecl *Class);
+  void LookupConstructors(CXXRecordDecl *Class,
+                          llvm::SmallVectorImpl<NamedDecl*> &Constructors);
   CXXConstructorDecl *LookupDefaultConstructor(CXXRecordDecl *Class);
   CXXConstructorDecl *LookupCopyingConstructor(CXXRecordDecl *Class,
                                                unsigned Quals);
diff --git a/lib/Sema/SemaCodeComplete.cpp b/lib/Sema/SemaCodeComplete.cpp
index e4bbee86e3..16e0c41d27 100644
--- a/lib/Sema/SemaCodeComplete.cpp
+++ b/lib/Sema/SemaCodeComplete.cpp
@@ -5212,7 +5212,9 @@ QualType Sema::ProduceConstructorSignatureHelp(Scope *S, QualType Type,
 
   OverloadCandidateSet CandidateSet(Loc, OverloadCandidateSet::CSK_Normal);
 
-  for (NamedDecl *C : LookupConstructors(RD)) {
+  llvm::SmallVector<NamedDecl*, 4> Ctors;
+  LookupConstructors(RD, Ctors);
+  for (NamedDecl *C : Ctors) {
     if (auto *FD = dyn_cast<FunctionDecl>(C)) {
       AddOverloadCandidate(FD, DeclAccessPair::make(FD, C->getAccess()), Args,
                            CandidateSet,
diff --git a/lib/Sema/SemaDeclCXX.cpp b/lib/Sema/SemaDeclCXX.cpp
index bf76272525..13dc68e9bd 100644
--- a/lib/Sema/SemaDeclCXX.cpp
+++ b/lib/Sema/SemaDeclCXX.cpp
@@ -10162,7 +10162,9 @@ NamedDecl *Sema::BuildUsingDeclaration(
         UsingName.setName(Context.DeclarationNames.getCXXConstructorName(
             Context.getCanonicalType(Context.getRecordType(CurClass))));
         UsingName.setNamedTypeInfo(nullptr);
-        for (auto *Ctor : LookupConstructors(RD))
+        llvm::SmallVector<NamedDecl*, 4> Ctors;
+        LookupConstructors(RD, Ctors);
+        for (auto *Ctor : Ctors)
           R.addDecl(Ctor);
         R.resolveKind();
       } else {
diff --git a/lib/Sema/SemaExprCXX.cpp b/lib/Sema/SemaExprCXX.cpp
index cfb3754d15..e82e321090 100644
--- a/lib/Sema/SemaExprCXX.cpp
+++ b/lib/Sema/SemaExprCXX.cpp
@@ -4804,7 +4804,9 @@ static bool EvaluateUnaryTypeTrait(Sema &Self, TypeTrait UTT,
 
       bool FoundConstructor = false;
       unsigned FoundTQs;
-      for (const auto *ND : Self.LookupConstructors(RD)) {
+      llvm::SmallVector<NamedDecl*, 4> Ctors;
+      Self.LookupConstructors(RD, Ctors);
+      for (const auto *ND : Ctors) {
         // A template constructor is never a copy constructor.
         // FIXME: However, it may actually be selected at the actual overload
         // resolution point.
@@ -4845,7 +4847,9 @@ static bool EvaluateUnaryTypeTrait(Sema &Self, TypeTrait UTT,
         return true;
 
       bool FoundConstructor = false;
-      for (const auto *ND : Self.LookupConstructors(RD)) {
+      llvm::SmallVector<NamedDecl*, 4> Ctors;
+      Self.LookupConstructors(RD, Ctors);
+      for (const auto *ND : Ctors) {
         // FIXME: In C++0x, a constructor template can be a default constructor.
         if (isa<FunctionTemplateDecl>(ND->getUnderlyingDecl()))
           continue;
diff --git a/lib/Sema/SemaInit.cpp b/lib/Sema/SemaInit.cpp
index 60f34775c6..75b4007214 100644
--- a/lib/Sema/SemaInit.cpp
+++ b/lib/Sema/SemaInit.cpp
@@ -3735,7 +3735,7 @@ ResolveConstructorOverload(Sema &S, SourceLocation DeclLoc,
                            MultiExprArg Args,
                            OverloadCandidateSet &CandidateSet,
                            QualType DestType,
-                           DeclContext::lookup_result Ctors,
+                           const llvm::SmallVectorImpl<NamedDecl*>& Ctors,
                            OverloadCandidateSet::iterator &Best,
                            bool CopyInitializing, bool AllowExplicit,
                            bool OnlyListConstructors, bool IsListInit,
@@ -3915,7 +3915,8 @@ static void TryConstructorInitialization(Sema &S,
   //   - Otherwise, if T is a class type, constructors are considered. The
   //     applicable constructors are enumerated, and the best one is chosen
   //     through overload resolution.
-  DeclContext::lookup_result Ctors = S.LookupConstructors(DestRecordDecl);
+  llvm::SmallVector<NamedDecl*, 4> Ctors;
+  S.LookupConstructors(DestRecordDecl, Ctors);
 
   OverloadingResult Result = OR_No_Viable_Function;
   OverloadCandidateSet::iterator Best;
@@ -4370,7 +4371,9 @@ static OverloadingResult TryRefInitWithConversionFunction(
     // to see if there is a suitable conversion.
     CXXRecordDecl *T1RecordDecl = cast<CXXRecordDecl>(T1RecordType->getDecl());
 
-    for (NamedDecl *D : S.LookupConstructors(T1RecordDecl)) {
+    llvm::SmallVector<NamedDecl*, 4> Ctors;
+    S.LookupConstructors(T1RecordDecl, Ctors);
+    for (NamedDecl *D : Ctors) {
       auto Info = getConstructorInfo(D);
       if (!Info.Constructor)
         continue;
@@ -5014,7 +5017,9 @@ static void TryUserDefinedConversion(Sema &S,
 
     // Try to complete the type we're converting to.
     if (S.isCompleteType(Kind.getLocation(), DestType)) {
-      for (NamedDecl *D : S.LookupConstructors(DestRecordDecl)) {
+      llvm::SmallVector<NamedDecl*, 4> Ctors;
+      S.LookupConstructors(DestRecordDecl, Ctors);
+      for (NamedDecl *D : Ctors) {
         auto Info = getConstructorInfo(D);
         if (!Info.Constructor)
           continue;
@@ -5987,7 +5992,8 @@ static ExprResult CopyObject(Sema &S,
   // C++11 [dcl.init]p16, second bullet for class types, this initialization
   // is direct-initialization.
   OverloadCandidateSet CandidateSet(Loc, OverloadCandidateSet::CSK_Normal);
-  DeclContext::lookup_result Ctors = S.LookupConstructors(Class);
+  llvm::SmallVector<NamedDecl*, 4> Ctors;
+  S.LookupConstructors(Class, Ctors);
 
   OverloadCandidateSet::iterator Best;
   switch (ResolveConstructorOverload(
@@ -6129,8 +6135,8 @@ static void CheckCXX98CompatAccessibleCopy(Sema &S,
 
   // Find constructors which would have been considered.
   OverloadCandidateSet CandidateSet(Loc, OverloadCandidateSet::CSK_Normal);
-  DeclContext::lookup_result Ctors =
-      S.LookupConstructors(cast<CXXRecordDecl>(Record->getDecl()));
+  llvm::SmallVector<NamedDecl*, 4> Ctors;
+  S.LookupConstructors(cast<CXXRecordDecl>(Record->getDecl()), Ctors);
 
   // Perform overload resolution.
   OverloadCandidateSet::iterator Best;
diff --git a/lib/Sema/SemaLookup.cpp b/lib/Sema/SemaLookup.cpp
index 2958dd1412..aa5d2f34c5 100644
--- a/lib/Sema/SemaLookup.cpp
+++ b/lib/Sema/SemaLookup.cpp
@@ -3214,7 +3214,8 @@ CXXConstructorDecl *Sema::LookupMovingConstructor(CXXRecordDecl *Class,
 }
 
 /// Look up the constructors for the given class.
-DeclContext::lookup_result Sema::LookupConstructors(CXXRecordDecl *Class) {
+void Sema::LookupConstructors(CXXRecordDecl *Class,
+                              llvm::SmallVectorImpl<NamedDecl*> &Constructors) {
   // If the implicit constructors have not yet been declared, do so now.
   if (CanDeclareSpecialMemberFunction(Class)) {
     if (Class->needsImplicitDefaultConstructor())
@@ -3227,7 +3228,10 @@ DeclContext::lookup_result Sema::LookupConstructors(CXXRecordDecl *Class) {
 
   CanQualType T = Context.getCanonicalType(Context.getTypeDeclType(Class));
   DeclarationName Name = Context.DeclarationNames.getCXXConstructorName(T);
-  return Class->lookup(Name);
+  // Working directly on R might trigger a deserialization, invalidating R if
+  // the underlying data structure needs to reallocate the storage.
+  DeclContext::lookup_result R = Class->lookup(Name);
+  Constructors.append(R.begin(), R.end());
 }
 
 /// Look up the copying assignment operator for the given class.
@@ -3462,7 +3466,10 @@ void Sema::ArgumentDependentLookup(DeclarationName Name, SourceLocation Loc,
     //        namespaces even if they are not visible during an ordinary
     //        lookup (11.4).
     DeclContext::lookup_result R = NS->lookup(Name);
-    for (auto *D : R) {
+    // The loop might trigger a deserialization, invalidating R if the
+    // underlying data structure needs to reallocate the storage.
+    llvm::SmallVector<NamedDecl*, 8> RCopy(R.begin(), R.end());
+    for (auto *D : RCopy) {
       auto *Underlying = D;
       if (auto *USD = dyn_cast<UsingShadowDecl>(D))
         Underlying = USD->getTargetDecl();
diff --git a/lib/Sema/SemaOverload.cpp b/lib/Sema/SemaOverload.cpp
index f632a4d3bd..b176a9c6a7 100644
--- a/lib/Sema/SemaOverload.cpp
+++ b/lib/Sema/SemaOverload.cpp
@@ -3230,7 +3230,9 @@ IsInitializerListConstructorConversion(Sema &S, Expr *From, QualType ToType,
                                        OverloadCandidateSet &CandidateSet,
                                        bool AllowExplicit) {
   CandidateSet.clear(OverloadCandidateSet::CSK_InitByUserDefinedConversion);
-  for (auto *D : S.LookupConstructors(To)) {
+  llvm::SmallVector<NamedDecl*, 4> Ctors;
+  S.LookupConstructors(To, Ctors);
+  for (auto *D : Ctors) {
     auto Info = getConstructorInfo(D);
     if (!Info)
       continue;
@@ -3353,7 +3355,9 @@ IsUserDefinedConversion(Sema &S, Expr *From, QualType ToType,
         ListInitializing = true;
       }
 
-      for (auto *D : S.LookupConstructors(ToRecordDecl)) {
+      llvm::SmallVector<NamedDecl*, 4> Ctors;
+      S.LookupConstructors(ToRecordDecl, Ctors);
+      for (auto *D : Ctors) {
         auto Info = getConstructorInfo(D);
         if (!Info)
           continue;
diff --git a/lib/Sema/SemaTemplate.cpp b/lib/Sema/SemaTemplate.cpp
index 520c89ee98..6ada88492f 100644
--- a/lib/Sema/SemaTemplate.cpp
+++ b/lib/Sema/SemaTemplate.cpp
@@ -2158,7 +2158,9 @@ void Sema::DeclareImplicitDeductionGuides(TemplateDecl *Template,
   // for which some class template parameter without a default argument never
   // appears in a deduced context).
   bool AddedAny = false;
-  for (NamedDecl *D : LookupConstructors(Transform.Primary)) {
+  llvm::SmallVector<NamedDecl*, 4> Ctors;
+  LookupConstructors(Transform.Primary, Ctors);
+  for (NamedDecl *D : Ctors) {
     D = D->getUnderlyingDecl();
     if (D->isInvalidDecl() || D->isImplicit())
       continue;
-- 
2.35.1

